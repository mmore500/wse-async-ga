const genome = @import_module("cerebraslib/genome/genome_bitdrift.csl");
const population = @import_module("cerebraslib/population.csl", .{
    .genome = genome, .popSize = 100,
    .tournamentSize = 3.0, .pExtinction = 0.0,
});

const genomeFrozen = @import_module(
    "cerebraslib/genome/genome_frozenliteral3.csl",
);
const populationExtinction = @import_module("cerebraslib/population.csl", .{
    .genome = genomeFrozen, .popSize = 2,
    .tournamentSize = 3.0, .pExtinction = 1.0,
});

const genomeClobber = @import_module(
    "cerebraslib/genome/genome_bitdrift_clobber.csl",
);
const populationClobber = @import_module("cerebraslib/population.csl", .{
    .genome = genomeClobber, .popSize = 2,
    .tournamentSize = 3.0, .pExtinction = 1.0,
});

// internal accessors ======================================================
fn test_calc_ith_fitness() void { population._calc_ith_fitness(0); }

fn test_elapse_ith_inheritance() void { population._elapse_ith_inheritance(0); }

fn test_get_ith_genome() void { population._get_ith_genome(0); }

fn test_get_ith_trait_value() void { population._get_ith_trait_value(0); }

fn test_get_population_word() void { population._get_population_word(0); }

fn test_get_swap_word() void { population._get_swap_word(0); }

fn test_sample_one_tournament() void {
    population._sample_one_tournament();
    var i: f32 = 1.1;
    @assert(@as(i32, i) == 1);
    i = 1.9;
    @assert(@as(i32, i) == 1);
    i = 2.1;
    @assert(@as(i32, i) == 2);
}

fn test_scale_by_genome_words() void { population._scale_by_genome_words(0); }

// internal routines ==========================================================
fn test_eval_fitness_all() void { population._eval_fitness_all(); }

fn test_elapse_inheritance_all() void { population._elapse_inheritance_all(); }

fn test_perform_selection_all() void { population._perform_selection_all(); }

fn test_sample_n() void {
    population._sample_n(1);
    population._sample_n(2);
    population._sample_n(100);
    population._sample_n(99);
    population._sample_n(2);
}

fn test_perform_extinction_all() void {
    populationExtinction.init_module();
    @assert(populationExtinction._get_population_word(0) != 0);
    @assert(populationExtinction._get_population_word(1) != 0);
    @assert(populationExtinction._get_population_word(2) != 0);
    @assert(populationExtinction._get_population_word(3) != 0);
    @assert(populationExtinction._get_population_word(4) != 0);
    @assert(populationExtinction._get_population_word(5) != 0);
    populationExtinction._perform_extinction_all();
    @assert(populationExtinction._get_population_word(0) == 0);
    @assert(populationExtinction._get_population_word(1) == 0);
    @assert(populationExtinction._get_population_word(2) == 0);
    @assert(populationExtinction._get_population_word(3) == 0);
    @assert(populationExtinction._get_population_word(4) == 0);
    @assert(populationExtinction._get_population_word(5) == 0);

}

// public API =================================================================
fn test_emigrate_genomes() void {
    population.emigrate_genomes(population.swapDsd, 10);
}

fn test_immigrate_genomes() void {
    population.immigrate_genomes(@ptrcast([*]u32, &population.swap), 10);
}

fn test_immigrate_genomes_clobber() void {
    populationClobber.immigrate_genomes(
        @ptrcast([*]u32, &populationClobber.swap), 10
    );
}

fn test_do_generation() void { population.do_generation(); }

// test runner ================================================================
fn do_test() void {
    population.init_module();
    test_calc_ith_fitness();
    test_elapse_ith_inheritance();
    test_get_ith_genome();
    test_get_ith_trait_value();
    test_get_population_word();
    test_get_swap_word();
    test_sample_one_tournament();
    test_scale_by_genome_words();
    test_eval_fitness_all();
    test_elapse_inheritance_all();
    test_perform_selection_all();
    test_sample_n();
    test_perform_extinction_all();
    test_emigrate_genomes();
    test_immigrate_genomes();
    test_immigrate_genomes_clobber();
    test_do_generation();
}
