const math = @import_module("<math>");
const random = @import_module("<random>");

var _as16 = [2]u16{0, 0};  // csl requires global access for dsd
const _dsd_as16 = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{2} -> _as16[i],
});

/// Add two 32-bit integers.
fn add32(a: u32, b: u32) u32 { return a + b; }

/// Count leading zeros in a 32-bit integer.
fn clz32(n: u32) u32 {
    _as16[0] = @as(u16, n);
    _as16[1] = @as(u16, n >> 16);
    @clz(_dsd_as16, _dsd_as16);
    return @as(u32, _as16[1] + (_as16[0] * @as(u16, _as16[1] == 16)));
}

/// Count trailing zeros in a 32-bit integer.
fn ctz32(n: u32) u32 {
    _as16[0] = @as(u16, n);
    _as16[1] = @as(u16, n >> 16);
    @ctz(_dsd_as16, _dsd_as16);
    return @as(u32, _as16[0] + (_as16[1] * @as(u16, _as16[0] == 16)));
}

/// Increment a 32-bit integer by one
fn incr16(a: u16) u16 { return a + 1; }

/// Increment a 32-bit integer by one
fn incr32(a: u32) u32 { return a + 1; }

/// Increment a 32-bit integer by one, modulo a given value.
fn incrmod32(val: u32, mod: u32) u32 {
    const res = val + 1;
    const correction = @as(u32, res < mod);
    return res * correction;
}

/// Multiply two 32-bit integers.
fn mul32(a: u32, b: u32) u32 { return a * b; }

// Sample a coin flip with probability p.
fn p(probability: f32) bool {
    return random.random_f32(0.0, 1.0) < probability;
}

/// Draw a random 32-bit integer from a poisson distribution with shape lambda
/// Adapted from https://en.wikipedia.org/wiki/Poisson_distribution
fn poisson32(lambda: f32) u32 {
    var x: u32 = 0;
    var p: f32 = math.exp(-lambda);
    var s: f32 = p;
    const u = random.random_f32(0.0, 1.0);

    while (u > s) {
        x += 1;
        p *= lambda / @as(f32, x);
        s += p;
    }

    return x;
}

/// Population count of an integer, i.e., number of set bits.
fn popcnt32(n: u32) u32 {
    _as16[0] = @as(u16, n);
    _as16[1] = @as(u16, n >> 16);
    @popcnt(_dsd_as16, _dsd_as16);
    return @as(u32, _as16[0] + _as16[1]);
}

/// Draw a random 16-bit integer from a uniform distribution, with a given
/// upper bound (exclusive).
fn unif16(upper: u16) u16 {
    return math.min( // explicitly enforce bounds RE float precision
        @as(u16, random.random_f32(0.0, @as(f32, upper))),
        upper - 1,
    );
}

/// Draw a random boolean value (even coin flip)..
fn unifbool() bool { return p(0.5); }

/// Return the n-th next representable f32 toward +Inf (Julia semantics).
fn nextf32(x: f32, n: u32) f32 {
    const bits = @bitcast(u32, x);
    const mag = bits & 0x7FFFFFFF;
    if (mag > 0x7F800000) return x; // NaN: pass through
    if (bits < 0x80000000) // non-negative: increment mag, clamp at +Inf
        return @bitcast(f32, mag + math.min(n, 0x7F800000 - mag));
    // negative: decrement mag toward zero
    if (n <= mag) return @bitcast(f32, 0x80000000 | (mag - n));
    return @bitcast(f32, math.min(n - mag, @as(u32, 0x7F800000))); // cross zero into positive
}

/// Return the n-th previous representable f32 toward -Inf (Julia semantics).
fn prevf32(x: f32, n: u32) f32 {
    const bits = @bitcast(u32, x);
    const mag = bits & 0x7FFFFFFF;
    if (mag > 0x7F800000) return x; // NaN: pass through
    if (bits >= 0x80000000) // negative: increment mag, clamp at -Inf
        return @bitcast(f32, 0x80000000 | (mag + math.min(n, 0x7F800000 - mag)));
    // non-negative: decrement mag toward zero
    if (n <= mag) return @bitcast(f32, mag - n);
    return @bitcast(f32, 0x80000000 | math.min(n - mag, @as(u32, 0x7F800000))); // cross zero into negative
}

/// Return the n-th next representable f16 toward +Inf (Julia semantics).
fn nextf16(x: f16, n: u16) f16 {
    const bits = @bitcast(u16, x);
    const mag = bits & 0x7FFF;
    if (mag > 0x7C00) return x; // NaN: pass through
    if (bits < 0x8000) // non-negative: increment mag, clamp at +Inf
        return @bitcast(f16, mag + math.min(n, 0x7C00 - mag));
    // negative: decrement mag toward zero
    if (n <= mag) return @bitcast(f16, 0x8000 | (mag - n));
    return @bitcast(f16, math.min(n - mag, @as(u16, 0x7C00))); // cross zero into positive
}

/// Return the n-th previous representable f16 toward -Inf (Julia semantics).
fn prevf16(x: f16, n: u16) f16 {
    const bits = @bitcast(u16, x);
    const mag = bits & 0x7FFF;
    if (mag > 0x7C00) return x; // NaN: pass through
    if (bits >= 0x8000) // negative: increment mag, clamp at -Inf
        return @bitcast(f16, 0x8000 | (mag + math.min(n, 0x7C00 - mag)));
    // non-negative: decrement mag toward zero
    if (n <= mag) return @bitcast(f16, mag - n);
    return @bitcast(f16, 0x8000 | math.min(n - mag, @as(u16, 0x7C00))); // cross zero into negative
}
