// memory layout ===============================================================
// byte 0 FLAG SITES (8 bytes)
// byte 1
// byte 2
// byte 3
// byte 4
// byte 5
// byte 6
// byte 7
// byte 8 COUNTER (u32, 4 bytes)
// byte 9
// byte 10
// byte 11
// byte 12 BITFIELD (16 bytes)
// byte 13
// byte 14
// byte 15
// byte 16
// byte 17
// byte 18
// byte 19
// byte 20
// byte 21
// byte 22
// byte 23
// byte 24
// byte 25
// byte 26
// byte 27
// TOTAL: 7 words -> 28 bytes

//! {
//!     "dstream_algo": (
//!         "dstream." + compconf_data.get(
//!             "CEREBRASLIB_HSTRAT_DSTREAM_ALGO_NAME:comptime_string", "hybrid_0_steady_1_tilted_2_algo"
//!         ),
//!         pl.Categorical,
//!     ),
//!     "dstream_storage_bitoffset": (96, pl.UInt8),
//!     "dstream_storage_bitwidth": (128, pl.UInt8),
//!     "dstream_T_bitoffset": (64, pl.UInt8),
//!     "dstream_T_bitwidth": (32, pl.UInt8),
//!     "dstream_S": (128, pl.UInt8),
//!     "flag_site_bitwidth": (1, pl.UInt8),
//!     "flag_sites_bitoffset": (0, pl.UInt8),
//!     "flag_sites_bitwidth": (64, pl.UInt8),
//!     "flag_is_focal_mask_byte0": (0x00, pl.UInt8),
//!     "flag_is_focal_mask_byte1": (0x00, pl.UInt8),
//!     "flag_is_focal_mask_byte2": (0x00, pl.UInt8),
//!     "flag_is_focal_mask_byte3": (0x01, pl.UInt8),
//!     "flag_is_focal_mask_byte4": (0x00, pl.UInt8),
//!     "flag_is_focal_mask_byte5": (0x00, pl.UInt8),
//!     "flag_is_focal_mask_byte6": (0x00, pl.UInt8),
//!     "flag_is_focal_mask_byte7": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte0": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte1": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte2": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte3": (0x0F, pl.UInt8),
//!     "flag_nand_mask_byte4": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte5": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte6": (0x00, pl.UInt8),
//!     "flag_nand_mask_byte7": (0x00, pl.UInt8),
//!     "nWav": (7, pl.UInt8),
//! }

// module imports =============================================================
const math = @import_module("<math>");
const random = @import_module("<random>");

const compconf = @import_module("<compconf>");
comptime { // access via get_value for logging...
    const _ = compconf.get_value_or(
        "CEREBRASLIB_HSTRAT_DSTREAM_ALGO_NAME",
        "hybrid_0_steady_1_tilted_2_algo",
    );
} // ... raw string works around sdk v1.0.0 limitation
const compconf_raw = @import_module("<compconf_raw>");
const has_value = compconf.has_value("CEREBRASLIB_HSTRAT_DSTREAM_ALGO_NAME");
const dstream_algo_name = (if (has_value)
    compconf_raw.CEREBRASLIB_HSTRAT_DSTREAM_ALGO_NAME
else
    "hybrid_0_steady_1_tilted_2_algo");
const dstream_algo = @import_module(
    @strcat("<downstream/dstream/", dstream_algo_name, ">"),
);

const bitmanip = @import_module("cerebraslib/bitmanip.csl");
const opscalar = @import_module("cerebraslib/opscalar.csl");

const S = 128;

// module config specs ========================================================
const gSize: u16 = 7;
const genome_t = [gSize]u32;
const genomePtr_t = [*]u32;
const nTraitVals: u16 = 3;
const hasImmClobber: bool = true;

// internal functions =========================================================
fn _apply_mutation(genome: genomePtr_t, log2p: u8) void {
    bitmanip.mutate_log2p(@ptrcast([*]u16, genome), 4, log2p);
}

fn _step_instrumentation(genome: genomePtr_t) void {
    // elapse generation in bitfield
    if (opscalar.unifbool()) {
        const T = @ptrcast([*]u32, genome)[2];
        const site = dstream_algo.assign_storage_site(S, T);

        const offset_bits: u16 = (8 + 4) * 8;
        const target_bit = @as(u16, site) + offset_bits;

        const genome_bytes = @ptrcast([*]u8, genome);
        if (site != S) bitmanip.flip_nth_bit_with_swaps(
            genome_bytes,
            target_bit,
            .{ .byteSwap = true, .bitSwap = true },
        );
    }

    // elapse generation in counter
    @ptrcast([*]u32, genome)[2] += 1;
}

inline fn _clear(genome: genomePtr_t) void {
    genome[0] = 0;
    genome[1] = 0;
    genome[2] = 0;
    genome[3] = 0;
    genome[4] = 0;
    genome[5] = 0;
    genome[6] = 0;
}

inline fn _is_clear(genome: genomePtr_t) bool {
    const res: bool = genome[2] == 0;
    return res;
}

const _pmut_log2: u8 = compconf.get_value_or( //nofmt
    "CEREBRASLIB_LOG2_PMUT_BITWISE", // nofmt
    @as(u8, 18), // nofmt
);

const _fit_fudge: f32 = compconf.get_value_or( //nofmt
    "CEREBRASLIB_NONZERO_FIT_FUDGE", @as(f32, 0.0) // nofmt
);

const _p_clobber: f32 = compconf.get_value_or( //nofmt
    "CEREBRASLIB_CLOBBER_IMMIGRANT_P", @as(f32, 0.9) // nofmt
);

// public API =================================================================

fn elapse_inheritance_of(genome: genomePtr_t) void {
    if (!_is_clear(genome)) {
        _apply_mutation(genome, _pmut_log2);
        _step_instrumentation(genome); // elapse two steps per generation
        _step_instrumentation(genome);
    }
}

fn calc_fitness_of(genome: genomePtr_t) f32 {
    var fitness = @as(f32, get_trait_value(genome));
    if (fitness != 0.0) {
        fitness += random.random_f32(0.0, _fit_fudge);
    }
    return fitness;
}

fn get_trait_value(genome: genomePtr_t) u32 {
    // note: bottom 8 sites initialized as 1's
    const is_not_clear: u32 = @as(u32, !_is_clear(genome));
    const has_focal_mut: u32 = (genome[0] & 1) ^ is_not_clear;
    // 0: is_clear
    // 1: not clear, no focal mutation
    // 2: not clear, has focal mutation
    return is_not_clear + has_focal_mut;
}

fn initialize_one(genome: genomePtr_t) void {
    _clear(genome);
    genome[0] |= 0x0F; // initialize bottom 4 sites as 1's
    // (to hint for testing endianness when decoding)
    genome[2] = S; // initialize counter to S
    // randomize hstrat bitfield
    bitmanip.randomize(@ptrcast([*]u16, &genome[3]), 8);
}

fn clobber_immigrant(resident: genomePtr_t, immigrant: genomePtr_t) void {
    const is_occupied = !_is_clear(resident);
    if (is_occupied or ( // nofmt
        (get_trait_value(immigrant) == 2) and opscalar.p(_p_clobber)))
    {
        _clear(immigrant);
    }
}
